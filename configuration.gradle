import java.nio.file.Files
import java.nio.file.Paths

project.ext {

  cfgJavaVersion = "1.8"

  cfgVersion = "1.2.0"

  cfgGroup = "de.ninjaneers"

  cfgCopyDependencies = false

  cfgCopyToRoot = false

  cfgSignPom = true

  cfgRepository = project.properties.sonatypeRepository

  cfgSnapshotRepository = project.properties.sonatypeSnapshotRepository

  cfgRepositoryUser = project.properties.sonatypeUser

  cfgRepositoryPass = project.properties.sonatypePass

  javaProjects = allprojects

  distributionProjects = javaProjects

  docProjects = javaProjects

  repositoryProjects = javaProjects
}

tasks.withType(Tar) {

  dependsOn("copyJavadoc")

  into(project.name) {
    from("./") {
      include "build.gradle"
      include "configuration.gradle"
      include "license/**"
      include "docs/**"
      include "gradle/wrapper/**"
      include "gradlew"
      include "gradlew.bat"
      include "build/libs/**"
      include "src/**"
      include "native/**"
      include "README.adoc"
    }
  }

}

//------------------project specific configurations--------------------

apply plugin: "java"
apply plugin: "eclipse"
apply plugin: "osgi"
apply plugin: "maven"
apply plugin: "signing"


jar {
  manifest {
    name = "jRxTx"
    instruction "Export-Package", "!*.internal.*,*"
  }
}

eclipse {
	jdt {
		javaRuntimeName = "J2SE-1.5"
	}
}

tasks.withType(Javadoc) {
  exclude "**/gnu/**"
  options.noTimestamp()
}


uploadArchives {
  repositories {
    mavenDeployer {
      pom.project {
        name "jRxTx"
        description "jRxTx is a library for Java serial communication."

        licenses {
          license {
            name "GNU Lesser General Public License 2.1 or later + linking exception"
            url "http://www.gnu.org/licenses/lgpl-2.1.html"
            distribution "repo"
          }
        }
      }
    }
  }
}

jar {
  manifest { // the manifest of the default jar is of type OsgiManifest
      instruction "Import-Package", "!gnu.io.internal.*, *"
  }
}

dependencies {
  testCompile "org.mockito:mockito-core:1.10.19"
  testCompile "org.powermock:powermock-api-mockito:1.6.4"
  testCompile "org.powermock:powermock-module-junit4:1.6.2"
}

sourceSets {
	main {
		java.srcDirs = ["src/main-rxtx/java", "src/main/java"]
	}
}

def libName = "librxtxSerial"
def bundleNativeCode = (String[])[]
def resDir = project.sourceSets.main.output.resourcesDir

def conf = [
        // downloaded
        ("build-download/linux-x86-64-" + libName + ".so"): [
                "target": "linux/x86-64",
                "annotation": "osname=Linux;processor=x86-64",
                "target_filename": libName + ".so",
        ],
        ("build-download/osx-x86-64-" + libName + ".jnilib"): [
                "target": "osx/x86-64",
                "annotation": "osname=MacOSX;processor=x86-64",
                "target_filename": libName + ".jnilib",
        ],
        ("build-download/linux-armel/" + libName + ".so"): [
                "target": "linux/armel",
                "annotation": "osname=Linux;processor=armel",
                "target_filename": libName + ".so",
        ],
        ("build-download/linux-arm/" + libName + ".so"): [
                "target": "linux/arm",
                "annotation": "osname=Linux;processor=arm",
                "target_filename": libName + ".so",
        ],
        ("build-download/win32-x86_64/rxtxSerial.dll"): [
                "target": "win32/x86_64",
                "annotation": "osname=win32;processor=x86_64",
                "target_filename": "rxtxSerial.dll",
        ],

        // built right here
        ("native/x86_64-*linux-*/.libs/" + libName + ".so"): [
                "target": "linux/x86-64",
                "annotation": "osname=Linux;processor=x86-64",
                "target_filename": libName + ".so",
        ],
        ("native/*-apple-darwin*/" + libName + ".jnilib"): [
                "target": "osx/x86-64",
                "annotation": "osname=MacOSX;processor=x86-64",
                "target_filename": libName + ".jnilib",
        ],
        ("native/arm-unknown-linux-gnueabi/.libs/" + libName + ".so"): [
                "target": "linux/armel",
                "annotation": "osname=Linux;processor=armel",
                "target_filename": libName + ".so",
        ],
        ("native/arm-unknown-linux-gnueabihf/.libs/" + libName + ".so"): [
                "target": "linux/arm",
                "annotation": "osname=Linux;processor=arm",
                "target_filename": libName + ".so",
        ],
        ("native/x86_64-w64-mingw32/rxtxSerial.dll"): [
                "target": "Win32/x86_64",
                "annotation": "osname=Win32;processor=x86_64",
                "target_filename": "rxtxSerial.dll",
        ],
]

task copyNativeLibs(dependsOn: compileJava) {

    conf.each { pattern, map ->
        fileTree(dir: ".", include: pattern).forEach { file ->
            println "Found file " + file
            def outFileName = map['target_filename']
            def outName = "libs/" + map['target'] + "/" + outFileName
            def fileOutDir = Paths.get(resDir.absolutePath, "libs", map['target'])

            doLast {
                copy {
                    from file
                    into fileOutDir
                    rename file.getName(), outFileName
                }
                copy {
                    from file
                    into "build-native/"
                    rename  file.getName(), map['target'].replaceAll('/', '-') + "-" + file.getName()
                }
            }

            bundleNativeCode = bundleNativeCode.plus(outName + ";" + map['annotation'])
        }
    }
    doLast {
        bundleNativeCode = bundleNativeCode.join(',')
        if(bundleNativeCode.length() > 0) {
            jar {
                manifest {
                    instruction "Bundle-NativeCode", bundleNativeCode
                }
            }
        }
    }
}


task(buildWithNative) {
  dependsOn(copyNativeLibs)
  dependsOn(build)
  tasks.findByName("build").mustRunAfter "copyNativeLibs"
  tasks.findByName("jar").mustRunAfter "copyNativeLibs"
  tasks.findByName("copyNativeLibs").mustRunAfter "processResources"
}


clean {
  /*file("native").listFiles().each{
  	File f ->
  		if (f.getName().contains("unknown")) {
  			delete f
  		}
  	}
  */
}

compileJava {
	options.encoding = "UTF-8"
    options.compilerArgs << "-Xlint:unchecked"
}



task javah(dependsOn: compileJava) {
  doLast{
	  def Nclasses = [
	    "gnu.io.RXTXCommDriver",
	    "gnu.io.CommPortIdentifier",
	    "gnu.io.RXTXVersion",
	    "gnu.io.I2C",
	    "gnu.io.LPRPort",
	    "gnu.io.RXTXPort",
	    "gnu.io.Zystem",
	    "gnu.io.Raw",
	    "gnu.io.RS485",
	    "gnu.io.ParallelPort"
	  ];

	  def nativeIncludes = "native/src/include"
	  def classpath = sourceSets.main.output.classesDir
	  for (Nclass in Nclasses) {

	    logger.info("Generating header for " + Nclass)

	    exec {
		  executable "javah"
		  args "-d", "$nativeIncludes", "-classpath", "$classpath" , Nclass
	    }
	  }
  }
}


task copyJavadoc(type: Sync, dependsOn: "javadoc") {
  from "build/docs/javadoc/"
  into "docs/javadoc/"
}

sourceSets {
  itest {
    compileClasspath += sourceSets.main.compileClasspath
    runtimeClasspath += sourceSets.main.runtimeClasspath
  }
}

task itest(type: Test){
  systemProperty "java.library.path", "/usr/lib/jni/"
  testClassesDir = sourceSets.itest.output.classesDir
  classpath = sourceSets.itest.runtimeClasspath
}

